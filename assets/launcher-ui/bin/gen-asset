#!/usr/bin/env node
import io from 'node:fs';
import mime from 'mime';
import { compress } from '@mongodb-js/zstd';

(async () => {
    const assets = io.readdirSync('./dist', {
        recursive: true,
    }).filter(v => io.statSync('./dist/' + v).isFile());

    const isCompressed = {};

    if (io.existsSync('../../src/client/resources/ui-dist/'))
        io.rmSync('../../src/client/resources/ui-dist/', { recursive: true, force: true });

    io.mkdirSync('../../src/client/resources/ui-dist/');
    io.mkdirSync('../../src/client/resources/ui-dist/assets');

    for (const v of assets) {
        const buffer = io.readFileSync('./dist/' + v);
        const compressed = await compress(buffer, 22);

        if (compressed.length < buffer.length) {
            isCompressed[v] = true;
            io.writeFileSync('../../src/client/resources/ui-dist/' + v + '.zst', compressed)
        } else {
            isCompressed[v] = false;
            io.writeFileSync('../../src/client/resources/ui-dist/' + v, buffer)
        }
    }

    const rc = '// GENERATED BY npm build\r\n// DO NOT MODIFY\r\n\r\n#include "resource.hpp"\r\n\r\n' + assets
        .map((v, i) => isCompressed[v] ? `ID_ASSET_${i}\tRCDATA\t"resources/ui-dist/${v.replaceAll('\\', '/')}.zst"` : `ID_ASSET_${i}\tRCDATA\t"resources/ui-dist/${v.replaceAll('\\', '/')}"`)
        .join('\r\n') + '\r\n';

    io.writeFileSync('../../src/client/resource.g.rc', rc);
    console.log(rc);

    const resource = '// GENERATED BY npm build\r\n// DO NOT MODIFY\r\n\r\n' + assets
        .map((v, i) => `#define ID_ASSET_${i} ${350 + i}`)
        .join('\r\n') + '\r\n';

    io.writeFileSync('../../src/client/resource.g.hpp', resource);
    console.log(resource);

    const header = `// GENERATED BY npm build
// DO NOT MODIFY

#pragma once
#include <map>
#include <string>
#include <saucer/webview.hpp>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#include <utils/compression.hpp>
#include <utils/memory.hpp>

#include "resource.hpp"

namespace laochan::embedded
{
    auto read_resource(const int id)
    {
        auto* const res = FindResource(nullptr, MAKEINTRESOURCE(id), RT_RCDATA);
        if (!res) throw std::runtime_error{ "unable to load resource" };

        auto* const handle = LoadResource(nullptr, res);
        if (!handle) throw std::runtime_error{ "unable to load resource" };

        return std::span<const std::uint8_t>(reinterpret_cast<std::uint8_t*>(LockResource(handle)), SizeofResource(nullptr, res));
    }

    auto read_resource_zstd(const int id)
    {
        auto resource = read_resource(id);

        auto decompressed = utils::compression::zstd::decompress(std::string{ LPSTR(resource.data()), resource.size()});
        auto buf = utils::memory::allocate<uint8_t>(decompressed.size());
        std::memcpy(buf, decompressed.data(), decompressed.size());

        return std::span<uint8_t>{ buf, decompressed.size() };
    }

    inline auto all()
    {
        std::map<std::string, saucer::embedded_file> rtn;

` + assets
            .map((v, i) => {
                const type = mime.getType(v);
                const id = `ID_ASSET_${i}`;
                const path = v.replaceAll('\\', '/');

                if (v === "index.html")
                    return `
        auto root = read_resource${isCompressed[v] ? '_zstd' : ''}(${id});
        rtn.emplace("${path}", saucer::embedded_file{"${type}", root});
        rtn.emplace("", saucer::embedded_file{"${type}", root});
`;
                else
                    return `        rtn.emplace("${path}", saucer::embedded_file{"${type}", read_resource${isCompressed[v] ? '_zstd' : ''}(${id})});`
            })
            .join('\r\n') + `

        return rtn;
    }
}

`

    io.writeFileSync('../../src/client/resources/all.hpp', header);
    console.log(header);
})();
