#!/usr/bin/env node
import io from 'node:fs';
import mime from 'mime';

const assets = io.readdirSync('./dist', {
    recursive: true,
}).filter(v => io.statSync('./dist/' + v).isFile());

const rc = '// GENERATED BY npm build\r\n// DO NOT MODIFY\r\n\r\n#include "resource.hpp"\r\n\r\n' + assets
    .map((v, i) => `ID_ASSET_${i}\tRCDATA\t"resources/ui-dist/${v.replaceAll('\\', '/')}"`)
    .join('\r\n') + '\r\n';

io.writeFileSync('../../src/client/resource.g.rc', rc);
console.log(rc);

const resource = '// GENERATED BY npm build\r\n// DO NOT MODIFY\r\n\r\n' + assets
    .map((v, i) => `#define ID_ASSET_${i} ${350 + i}`)
    .join('\r\n') + '\r\n';

io.writeFileSync('../../src/client/resource.g.hpp', resource);
console.log(resource);

const header = `// GENERATED BY npm build
// DO NOT MODIFY

#pragma once
#include <map>
#include <string>
#include <saucer/webview.hpp>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

#include "resource.hpp"

namespace laochan::embedded
{
    auto read_resource(const int id)
    {
        auto* const res = FindResource(nullptr, MAKEINTRESOURCE(id), RT_RCDATA);
        if (!res) throw std::runtime_error{ "unable to load resource" };

        auto* const handle = LoadResource(nullptr, res);
        if (!handle) throw std::runtime_error{ "unable to load resource" };

        return std::span<const std::uint8_t>(reinterpret_cast<std::uint8_t*>(LockResource(handle)), SizeofResource(nullptr, res));
    }

    inline auto all()
    {
        std::map<std::string, saucer::embedded_file> rtn;

` + assets
        .map((v, i) => {
            const type = mime.getType(v);
            const id = `ID_ASSET_${i}`;
            const path = v.replaceAll('\\', '/');

            if (v === "index.html")
                return `
        auto root = read_resource(${id});
        rtn.emplace("${path}", saucer::embedded_file{"${type}", root});
        rtn.emplace("", saucer::embedded_file{"${type}", root});
`;
            else
                return `        rtn.emplace("${path}", saucer::embedded_file{"${type}", read_resource(${id})});`
        })
        .join('\r\n') + `

        return rtn;
    }
}

`

io.writeFileSync('../../src/client/resources/all.hpp', header);
console.log(header);

if(io.existsSync('../../src/client/resources/ui-dist/'))
    io.rmSync('../../src/client/resources/ui-dist/', { recursive: true, force: true });

io.mkdirSync('../../src/client/resources/ui-dist/');
io.mkdirSync('../../src/client/resources/ui-dist/assets');

assets.forEach(v => {
    io.copyFileSync('./dist/' + v, '../../src/client/resources/ui-dist/' + v);
});
